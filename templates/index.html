<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Medulla AI</title>
  <link rel="stylesheet" href="/static/style.css"/>
</head>
<body>
  <div class="container">
    <header class="topbar">
      <div class="brand">
        <h1>🧠 Medulla AI</h1>
        <p class="tag">Simple. Fast. Friendly.</p>
      </div>

      <div class="actions" role="toolbar" aria-label="Controls">
        <button id="stop-btn" class="btn ghost" title="Stop/Resume AI">⛔ Stop</button>
        <button id="mute-btn" class="btn ghost" title="Mute/Unmute TTS">🔇 Mute</button>
        <button id="clear-btn" class="btn danger" title="Delete chat">🗑 Delete</button>
      </div>
    </header>

    <section class="controls-row">
      <div class="voice-controls">
        <button id="mic-btn" class="btn primary" title="Hold to speak or tap to toggle">
          🎙️ Speak
        </button>

        <label class="select-label">
          AI Voice:
          <select id="voice-select" class="select"></select>
        </label>
      </div>
      <div id="status" class="status hidden" aria-live="polite"></div>
    </section>

    <main id="chat" class="chat" role="log" aria-live="polite"></main>

    <footer class="composer">
      <input id="input" type="text" placeholder="Type your message…" autocomplete="off"/>
      <button id="send" class="btn accent">Send</button>
    </footer>
  </div>

  <script>
    // ===== Elements =====
    const chat = document.getElementById("chat");
    const input = document.getElementById("input");
    const sendBtn = document.getElementById("send");
    const stopBtn = document.getElementById("stop-btn");
    const muteBtn = document.getElementById("mute-btn");
    const clearBtn = document.getElementById("clear-btn");
    const micBtn = document.getElementById("mic-btn");
    const voiceSelect = document.getElementById("voice-select");
    const statusBar = document.getElementById("status");

    // ===== State =====
    let isStopped = false;
    let isMuted = false;
    let isListening = false;
    let currentVoice = null;

    // ===== Helpers =====
    function addMessage(text, who) {
      const bubble = document.createElement("div");
      bubble.className = "msg " + (who === "user" ? "user" : who === "bot" ? "bot" : "note");
      bubble.innerText = text;
      chat.appendChild(bubble);
      chat.scrollTop = chat.scrollHeight;
      return bubble;
    }

    function setStatus(text, show = true, type = "") {
      if (!show) {
        statusBar.className = "status hidden";
        statusBar.innerText = "";
        return;
      }
      statusBar.className = "status " + type;
      statusBar.innerText = text;
    }

    // ===== Sanitizer for TTS =====
    function sanitizeForSpeech(text) {
      if (!text) return "";
      let t = text.replace(/[*`_#•►→·•°]/g, " ");
      t = t.replace(/\[([^\]]+)\]\((?:[^)]+)\)/g, "$1");      // [x](y) -> x
      t = t.replace(/```[\s\S]*?```/g, " ");                  // code fences
      t = t.replace(/`([^`]+)`/g, "$1");                      // inline code
      t = t.replace(/\b(asterisk|star|dash|hyphen|bullet|dot)\b/gi, " ");
      t = t.replace(/\n{2,}/g, ". ");
      t = t.replace(/\n/g, " ");
      t = t.replace(/[-*_]{2,}/g, " ");
      t = t.replace(/\s+/g, " ").trim();
      return t;
    }

    // ===== Speech Synthesis (TTS) =====
    function populateVoices() {
      const voices = window.speechSynthesis.getVoices() || [];
      // Prefer 2 female + 2 male English voices if available
      const isEn = v => /en(-|_)?/i.test(v.lang || "");
      const femKeys = ["aria", "jenny", "zoe", "sara", "natasha", "salli", "emma", "en-GB female", "en-US female"];
      const maleKeys = ["guy", "brian", "matthew", "arthur", "daniel", "en-GB male", "en-US male", "george"];

      const fem = voices.filter(v => isEn(v) && femKeys.some(k => (v.name || "").toLowerCase().includes(k))).slice(0, 2);
      const male = voices.filter(v => isEn(v) && maleKeys.some(k => (v.name || "").toLowerCase().includes(k))).slice(0, 2);

      let picked = [...fem, ...male];

      // If we didn't get 4, fill with any English voices, then any remaining
      if (picked.length < 4) {
        const fill = voices.filter(v => !picked.includes(v) && isEn(v)).slice(0, 4 - picked.length);
        picked = picked.concat(fill);
      }
      if (picked.length < 4) {
        const fill2 = voices.filter(v => !picked.includes(v)).slice(0, 4 - picked.length);
        picked = picked.concat(fill2);
      }

      voiceSelect.innerHTML = "";
      picked.forEach((v, idx) => {
        const opt = document.createElement("option");
        opt.value = v.name;
        opt.innerText = v.name || `Voice ${idx + 1}`;
        voiceSelect.appendChild(opt);
      });

      // set currentVoice
      const chosenName = voiceSelect.value;
      currentVoice = (window.speechSynthesis.getVoices() || []).find(v => v.name === chosenName) || null;
    }

    function speak(text) {
      if (isMuted) return;
      const t = sanitizeForSpeech(text);
      if (!("speechSynthesis" in window) || !t) return;
      try {
        window.speechSynthesis.cancel();
        const u = new SpeechSynthesisUtterance(t);
        if (currentVoice) u.voice = currentVoice;
        u.rate = 1;
        u.pitch = 1;
        window.speechSynthesis.speak(u);
      } catch (e) {
        console.warn("Speech failed:", e);
      }
    }

    voiceSelect.addEventListener("change", () => {
      const voices = window.speechSynthesis.getVoices() || [];
      currentVoice = voices.find(v => v.name === voiceSelect.value) || null;
      setStatus(`AI voice set to: ${voiceSelect.value}`, true);
      setTimeout(() => setStatus("", false), 1200);
    });

    if ("speechSynthesis" in window) {
      window.speechSynthesis.onvoiceschanged = populateVoices;
      // Some browsers need a kick to load voices
      setTimeout(populateVoices, 300);
    }

    // ===== Speech Recognition (STT) =====
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recog = null;
    if (SR) {
      recog = new SR();
      recog.lang = "en-US";           // change if you want another language
      recog.interimResults = false;
      recog.maxAlternatives = 1;

      recog.onstart = () => {
        isListening = true;
        micBtn.classList.add("recording");
        setStatus("Listening… speak now", true, "info");
      };
      recog.onend = () => {
        isListening = false;
        micBtn.classList.remove("recording");
        setStatus("", false);
      };
      recog.onerror = (e) => {
        isListening = false;
        micBtn.classList.remove("recording");
        setStatus("Mic error: " + (e.error || "unknown"), true, "warn");
        setTimeout(() => setStatus("", false), 1500);
      };
      recog.onresult = (e) => {
        const transcript = e.results?.[0]?.[0]?.transcript || "";
        if (transcript) {
          input.value = transcript;
          addMessage("🎙️ " + transcript, "note");
        }
      };
    } else {
      micBtn.disabled = true;
      micBtn.title = "Speech Recognition not supported in this browser";
    }

    function toggleMic() {
      if (!recog) return;
      if (!isListening) {
        try { recog.start(); } catch {}
      } else {
        try { recog.stop(); } catch {}
      }
    }

    // Hold-to-talk as well as toggle:
    micBtn.addEventListener("click", toggleMic);
    micBtn.addEventListener("mousedown", () => { if (recog && !isListening) try{recog.start();}catch{} });
    micBtn.addEventListener("mouseup",   () => { if (recog && isListening)  try{recog.stop();}catch{} });
    micBtn.addEventListener("touchstart", (e) => { e.preventDefault(); if (recog && !isListening) try{recog.start();}catch{} }, {passive:false});
    micBtn.addEventListener("touchend",   (e) => { e.preventDefault(); if (recog && isListening)  try{recog.stop();}catch{} }, {passive:false});

    // ===== Chat actions =====
    async function sendMessage() {
      const text = input.value.trim();
      if (!text) return;

      if (isStopped) {
        addMessage("You: " + text, "user");
        addMessage("Medulla: (AI is stopped — resume to get an answer)", "bot");
        input.value = "";
        return;
      }

      input.value = "";
      addMessage("You: " + text, "user");
      const thinking = addMessage("Medulla is thinking…", "note");

      try {
        const res = await fetch("/ask", {
          method: "POST",
          headers: {"Content-Type": "application/json"},
          body: JSON.stringify({message: text})
        });
        const data = await res.json();
        thinking.remove();

        if (data.error) {
          addMessage("Error: " + data.error, "bot");
          speak("Sorry, I encountered an error.");
        } else {
          addMessage("Medulla: " + data.reply, "bot");
          speak(data.reply);
        }
      } catch (err) {
        try { thinking.remove(); } catch {}
        addMessage("Network error. Please try again.", "bot");
        speak("Network error. Please try again.");
        console.error(err);
      }
    }

    sendBtn.addEventListener("click", sendMessage);
    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") sendMessage();
    });

    stopBtn.addEventListener("click", () => {
      isStopped = !isStopped;
      stopBtn.classList.toggle("active", isStopped);
      stopBtn.innerText = isStopped ? "▶ Resume" : "⛔ Stop";
      setStatus(isStopped ? "AI stopped — resume to enable answers." : "AI running", isStopped, "warn");
      if (!isStopped) setStatus("", false);
    });

    muteBtn.addEventListener("click", () => {
      isMuted = !isMuted;
      muteBtn.classList.toggle("active", isMuted);
      muteBtn.innerText = isMuted ? "🔈 Unmute" : "🔇 Mute";
      setStatus(isMuted ? "Voice muted" : "Voice on", true);
      setTimeout(() => setStatus("", false), 800);
      if (isMuted && "speechSynthesis" in window) window.speechSynthesis.cancel();
    });

    clearBtn.addEventListener("click", () => {
      if ("speechSynthesis" in window) window.speechSynthesis.cancel();
      chat.innerHTML = "";
      setStatus("Chat cleared", true);
      setTimeout(() => setStatus("", false), 800);
    });

    // Focus on load
    window.addEventListener("load", () => input.focus());
  </script>
</body>
</html>

